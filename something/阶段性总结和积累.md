## 代码规范
1.1.1、通常的模块分布：一般如果你要实现一个web应用，你从后台将数据展示到前端页面，在一个比较大的公司，你少不了跟其他项目有交集（你调用他的接口，他依赖你的接口），这样下来，整个公司有很多个模块，怎么做到很好的联系。回到刚刚的模块分布，你的一个web应用，应当需要分成三个模块：core模块、service模块、web模块。web模块就是展示到页面，后台代码而言主要就controller层了，其他逻辑基本都放在core了，service模块就是一些接口类和参数dto等等，接口的实现类在core模块。这样下来，web模块只需要依赖service模块，同样的其他系统依赖你的接口也仅仅是依赖service模块，然后利用远程调用方式消费你的接口服务。

1.1.2、代码层级结构：针对后台服务项目，一般分为对外接口层、service层、Dao层。Dao层就是与数据库交接的接口层，service层主要调用Dao或者外部系统的接口，复杂的逻辑基本都放在service层；一些方法需要提供给其他模块调用的时候，就封装在对外接口层，只有对外接口层是暴露。这里说的只是层级结构，还有与层级结构无关的，也是需要归类的，比如对外部系统接口方法封装的我们放在一个目录下面，一些常量和工具类等我们放在common目录下面。当然还有其他考虑，尽量让整个模块有层次感，代码才不会太乱，更好的维护。

1.1.3、总结上面两点：可能不少猿友觉得上面啰嗦又不像代码规范，其实这两点也是代码规范的一部分，主要引导大家往结构清晰好维护的思维方向走，多思考吧。

1.1.4、对于一些需要异步处理的，不要直接new一个thread，应当使用线程池。使用线程池的时候应当对线程数量大小合理设置，一般最大不超过50个，当然还需要考虑你的IO和CPU，怎么分析网上搜搜吧。

1.1.5、容器类变量，如果变化比较大且频繁，尽量定义的时候设置初始容量大小，减少扩容带来的消耗。

1.1.6、分支判断if…else的时候，最常符合的条件处理放在前面。

1.1.7、对象比较的时候常量放前面，养成好习惯，减少空指针的出现。

1.1.8、减少synchronized中等待处理的代码，能放在外面就尽量放在外面。

1.1.9、下面到数据库了，我觉得还是在这里说了好点，一般查询比较慢，很有可能是没有建索引或者索引没用到，多去检查一下。

1.1.10、两个大表的关联查询，可以使用二次访问数据库替代，先查出A表的数据，利用关联字段再查B表的。不要一味想着一条sql搞定最好。

1.1.11、坚决避免，查全表数据或者数量大的数据，返回list加载到内存中，一不小心查了100w数据，又查得比较频繁，内存的爆了。有这种风险的改成分页查询。

1.1.12、不要select *，按需取列。

1.1.13、多考虑避免事务里面有长连接或者长事务，如果大量这种情况出现占用数据连接，会影响性能。一些无必要的逻辑可以放到事务外执行。

1.1.14、对字段的加减乘除处理放到sql，严格避免先get处理，然后运算在set到数据库里面，并发情况非常容易导致失真。


## SQL规范与优化

1.2.1、先提前声明，博主工作用到是MySQL，可能有些场景只针对MySQL。说到SQL优化，一些概念必须要理解，不然死记硬背一两天就忘记了。特别是执行计划的概念。   

1.2.2、 什么是执行计划： a.决定如何访问表数据，是否通过索引，是否排序等。 b.多表关联是先访问哪个表。 c. 多表关联时，使用哪种连接方式，不过现在的Mysql只有嵌套连接（嵌套循环，就是将一个表为出发点，将该表所有记录逐条去遍历另外一张表的记录）   

1.2.3、 SQL执行顺序： a. 检查语法是否正确。 b. 检查表是否存在、权限是否满足等。 c.根据统计信息（data length , rows, index length, 索引唯一度），生成较优的执行计划。 d. 根据执行计划，进行数据检索、过滤、合并、排序操作。访问数据时，内存中如存在表数据，则直接进行操作，否则从磁盘中读取表数据，放入到内存中，再进行操作，如内存不足，则内存中较冷数据涮出内存，再从内存中读取数据。    

1.2.4、 索引：查询的时候如果使用上了索引，可以提高效率，因为建立了索引后，可以理解为数据字典的结构存储，因此根据条件查询的时候更加高效。下面看一下MySQL常用的索引类型的概念。     
a. 普通索引：在创建普通索引时，不附加任何限制条件。这类索引可以创建在任何数据类型中，其值是否唯一和非空由字段本身的完整性约束条件决定。建立索引以后，查询时可以通过索引进行查询。例如，在student表的stu_id字段上建立一个普通索引。查询记录时，就可以根据该索引进行查询。  

b. 唯一性索引:使用UNIQUE参数可以设置索引为唯一性索引。在创建唯一性索引时，限制该索引的值必须是唯一的。例如，在student表的stu_name字段中创建唯一性索引，那么stu_name字段的值就必需是唯一的。通过唯一性索引，可以更快速地确定某条记录。主键就是一种特殊唯一性索引。   

c. 单列索引:在表中的单个字段上创建索引。单列索引只根据该字段进行索引。单列索引可以是普通索引，也可以是唯一性索引，还可以是全文索引。只要保证该索引只对应一个字段 即可。   

d. 多列索引：多列索引是在表的多个字段上创建一个索引。该索引指向创建时对应的多个字段，可以通过这几个字段进行查询。但是，只有查询条件中使用了这些字段中第一个字段时，索引才会被使用。例如，在表中的id、name和sex字段上建立一个多列索引，那么，只有查询条件使用了id字段时该索引才会被使用。   

e . 全文索引：使用FULLTEXT参数可以设置索引为全文索引。全文索引只能创建在CHAR、VARCHAR或TEXT类型的字段上。查询数据量较大的字符串类型的字段时，使用全文索引可以提高查询速度。例如，student表的information字段是TEXT类型，该字段包含了很多的文字信息。在information字段上建立全文索引后，可以提高查询information字段的速度。MySQL数据库从3.23.23版开始支持全文索引，但只有MyISAM存储引擎支持全文检索。在默认情况下，全文索引的搜索执行方式不区分大小写。但索引的列使用二进制排序后，可以执行区分大小写的全文索引。

还有空间索引，平时也比较少用。目前只有MyISAM存储引擎支持空间检索。目前博主也只接触过InnoDB存储引擎。   

1.2.5、一般一张表索引不要超过5个，而且避免重复索引，而且也不是建了索引，根据索引字段条件查询，索引就会起作用。   

1.2.6、 导致索引失败的场景： a. 使用like关键字匹配字符串第一个为“%” 的场景。 b.条件中包含or、in、not in、 <>关键字，默认不走索引的。  c. 访问表上的数据行超出总记录数30%，变成全表扫描。 d. 查询条件使用函数在索引列上，或者对索引列进行运算。 e. 多列索引中， 第一个所有列进行范围查询，只能用到部分或者无法使用索引。  f. 多列索引中， 第一个查询条件不是最左索引列。   

1.2.7、不能同时使用两个索引，一个过滤数据，一个用于排序（主键除外）。  

1.2.8、DML语句如果使用索引，会导致lock全表；如果使用了非唯一索引，可能只是锁住一定范围。对此，建议更新/删除数据尽量用上索引，如果可以最好用上主键或唯一索引，另外事务要及时提交。

1.2.9、最后一点，如何看执行计划，分析SQL的性能。这个吧，三言两语说不清楚，直接看其他博主的博文吧：http://www.cnblogs.com/xiaoboluo768/p/5400990.html。一定要看！  

（3）关于事务的一些建议

如果没有听过事务这么个概念，网上了解学习一下，先理解一下各个事务类型的含义吧：a.日志记录尽量放在独立事务里面，避免后面的异常发生导致日志丢失。b.上面已经几次提到，尽早提交事务，避免事务过长，因此写代码的时候，一些可以不放到事务的逻辑可以移到外面，长事务看能否拆成两个事务。

（4）关于数据库连接池

可能一些猿友都少去注意吧。先来看看一些参数，这里只罗列了博主比较关注的，更多的可以自行查看一下配置。 
initialSize ： 默认值是 0, 连接池创建连接的初始连接数目。 
minIdle : 默认是 0, 连接数中最小空闲连接数。 
maxIdle : 默认是 8 ，连接池中最大空闲连接数。 
maxActive : 默认值是 8, 连接池中同时可以分派的最大活跃连接数。 
maxWait : 默认值是无限大，当连接池中连接已经用完了，等待建立一个新连接的最大毫秒数 ( 在抛异常之前 )。 
validationQuery : 一条 sql 语句，用来验证数据库连接是否正常。这条语句必须是一个查询模式，并至少返回一条数据。一般用“ select 1 ”。 
minEvictableIdleTimeMilis : 默认值是 1000 * 60 * 30(30 分钟 ) 单位也是毫秒，连接池中连接可空闲的时间。 
timeBetweenEvictionRunsMilis : 默认值是 -1 ，每隔一段多少毫秒跑一次回收空闲线程的线程。

对于minEvictableIdleTimeMilis、timeBetweenEvictionRunsMilis这两个参数，timeBetweenEvictionRunsMilis必须大于1且小于minEvictableIdleTimeMilis，建议是minEvictableIdleTimeMilis的五分之一或十分之一。   

[link](blog.csdn.net/u013142781/article/details/54099493)






