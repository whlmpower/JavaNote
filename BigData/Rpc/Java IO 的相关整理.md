# Java IO 的相关整理

## BIO 和 伪异步 IO

BIO 服务端通信模型，通常由一个独立的Acceptor线程负责监听客户端的连接，接收到客户端请求后为每一个独立的Accept线程负责监听客户端的连接，创建新的线程进行链路处理。

伪异步IO对上述单独创建线程的行为进行了优化，采用线程池的方式来处理多个客户端请求。

**伪异步IO的弊端**

对Socket的输入流进行读取操作的时候，会一直阻塞下去，直到发生以下三种事情：

1. 有数据可读
2. 可用数据已经读取完成
3. 发送空指针或者IO异常

下图左边对阻塞IO进行了说明，存在两个阻塞：建立连接的Accept线程会则塞监听连接请求；read 和 write阻塞。

前端只有一个Acceptor线程接收客户端接入，它被阻塞再线程池的同步阻塞队列之后，新的客户端请求的消息将被拒接，客户端会发生大量的连接超时。

当对方发送请求或者应答消息比较缓慢，或者网络传输缓慢时，读取输入流的以防通信线程将被长时间阻塞，会造成线程”假死“现象。当调用OutputStream 的 write方法写输出流的时候，将会被阻塞，直到要发送的字节全部写入完毕，或者发生异常。当消息的接收方处理缓慢的时候，将不能及时地从TCP缓冲区读取数据，这将导致发送方的TCP Window size不断减小，直到为0，双方处于Keep-Alive状态，消息发送方将不能再向TCP缓冲区写入消息，若采用同步IO，write操作将会被无限期阻塞，直到TCP window Size大于0 或者发生异常。 



![nio和传统io之间工作机制的差别](.\image\nio和传统io之间工作机制的差别.png)

向内核注册一个监听器（代码中写成selector），内核发现有事件，会进行事件通知，注册连接建立事件，由内核与客户端连接建立产生事件，注册read事件（channel对应于之前建立的tcp通道），客户端发送数据过来，kernel中tcp缓存交换到byteBuffer，写完后再次进行通知（可以read,通过事件通知回调）,通过channel读取

