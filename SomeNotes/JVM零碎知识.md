### 关于永久代
在JDK1.8 以前的HotSpot 实现中，类的元数据如方法数据， 方法信息，运行时常量池，已确定的符号引用和虚方法表等被保存在永久代，一旦类的元数据超过了永久代大小，就会抛出OOM异常。   
在JDK1.8 的HotSpot中，把永久代从Java堆中移除了，并把类的元数据保存在本地内存区域（堆外区域），成为元空间。  
这样做的好处：   
对永久代的调优非常困难，永久代的大小很难确定，其中涉及到很大因素，如**类的总数，常量池大小和方法数量**等，而且永久代的数据会随着每一次**fullGC而发生移动**。   
在JDK1.8中，**类的元数据保存在本地内存中，元数据的最大可分配内存为系统可用内存空间**，可以避免永久代的内存溢出问题，不过需要监控内存的消耗情况，一旦发生内存泄露，会占用大量的本地内存  
ps: JDK 1.7 以前的Hotspot, 字符串常量池的字符串被保存在永久代中，因此可能导致一系列的性能问题和内存溢出问题。在JDK1.8 字符串常量池**只保存对字符串**的引用  
类的元数据，字符串池，类的静态变量将从永久代中移除，将符号引用转移到了nativeheap，字面量转移到了java heap；类的静态变量转移到到了javaheap；类的元数据放入到本地内存中，字符串常量池放入到java堆中，这样加载多少类的元数据就不在有MAXPermSize控制，而是由系统的实际可用空间来控制。  
只要类加载器存活，其加载的类的元数据也是存活的，因而不会被回收掉。


[++参考++](https://www.cnblogs.com/hadoop-dev/p/7169252.html)  
**元空间虚拟机负责元空间的分配，其采用的形式为组块分配。组块的大小因类加载器的类型而异。在元空间虚拟机中存在一个全局的空闲组块列表。当一个类加载器需要组块时，它就会从这个全局的组块列表中获取并维持一个自己的组块列表。当一个类加载器不再存活，那么其持有的组块将会被释放**，并返回给全局组块列表。类加载器持有的组块又会被分成多个块，每一个块存储一个单元的元信息。组块中的块是线性分配（指针碰撞分配形式）。组块分配自内存映射区域。这些全局的虚拟内存映射区域以链表形式连接，一旦某个虚拟内存映射区域清空，这部分内存就会返回给操作系统。

### 元空间-内存分配模型
绝大多数类元数据的空间都是从本地内存中分配   
用来描述类元数据的类也被删除了，为元数据分配了多个虚拟内存空间   
给每个类加载器分配一个列表大小的内存块，只进行线性分配。块的大小取决于类加载器的类型。   
不会单独回收某个类，如果GC发现某个类加载器不再存活，会把相关的空间回收掉。减少了碎片，并节省了GC扫描和压缩时间   


### 可达性分析
GCRoot观察对象：
1. 本地变量表中的引用的对象
2. 方法区中静态变量引用的对象
3. 方法区中常量引用的对象
4. Native方法引用的对象  

在可达性分析法中，判定一个对象objA是否可回收，至少要经历两次标记过程：
1、如果对象objA到 GC Roots没有引用链，则进行第一次标记。
2、如果对象objA重写了finalize()方法，且还未执行过，那么objA会被插入到F-Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发其finalize()方法。finalize()方法是对象逃脱死亡的最后机会，GC会对队列中的对象进行第二次标记，如果objA在finalize()方法中与引用链上的任何一个对象建立联系，那么在第二次标记时，objA会被移出“即将回收”集合。