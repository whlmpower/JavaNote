## 1. MySQL锁概述
MYISAM 和MEMORY采用的是表级锁，InnoDB既支持行级锁也支持表级锁，默认采用行级锁  
表级锁：开销小，加锁快，不会出现死锁；锁力度大，发生冲突的概率高，并发度低    
行级锁：开销大，加锁慢，会出现死锁，锁力度小，发生概率低，并发度高。    
表级锁更适合**查询**为主，只有少量按索引条件更新数据的应用，如Web应用；   
行级锁更适用有**大量按索引条件**并发更新少量不同数据，同时又有并发查询的应用。

## 2. MYISAM表锁   
### 2.1 Mysql 表级锁的锁模式   
表共享读锁和表独占写锁（读读之间不加锁，读写之间、写写之间加锁）
MYISAM在执行查询语句（SELECT）前，会自动给设计的所有表加读锁，在执行更新操作（update，delete，INSERT）前，会自动给表加写锁，不需要用户显示加锁    
给MYISAM表显示加锁，一般是为了在一定程度上模拟事务操作，实现对某一个时间点多个数据的一致性读取    
在执行Lock Tables后，只能显示访问加锁的这些表，**不能访问未加锁的表**；加的是读锁，执行执行**查询操作**，不能执行**更新操作**。MYISAM总是一次性获得SQL语句所需要的全部锁。这也是MYISAM表**不会出现死锁**的原因。    
同一表出现多少次，通过与SQL语句中相同的**别名锁定多少次**    
### 2.2 并发插入
current_insert设置为0， 不允许并发插入    
current_insert设置为1，如果表中没有空洞（即表中没有被删除的行），MYISAM允许在一个进程读表的同时。另一个进程从表尾插入记录。    
current_insert设置为2，无论表中有没有空洞，都允许在表尾并发插入记录。    
利用并发插入特性来解决应用中对同一个**表查询和插入**的锁争用。   
### 2.3 MYISAM的锁调度   
默认写比读优先，即便是写操作在后。MYISAM不适合大量更新操作和查询操作应用的原因：**大量的更新操作让读操作很难得到读锁，从而永远阻塞。**   

## 3. InnoDB锁问题
InnoDB与MYISAM最大不同两点：一是支持事务，而是采用了行级锁
### 3.1 关于事务的知识（再次整理，不得精髓）
ACID 原子 一致 隔离 持久   
并发事务处理带来的更新问题：更新丢失、脏读、不可重复读、幻读。
不可重复读：一个事物在读取某些数据后的某个时间，再次读取以前读过的数据，却发现读取的数据已经发生了更新或者某些记录被删除（update, delete）    
幻读： 一个事务按照相同的查询条件重新获取以前检索过的记录，却发现其他事务插入了满足其查询条件的新数据。（insert）   
事务的隔离级别：未提交读 提交读  可重复读  可串行化    
数据库一致性问题：脏读、不可重复读、幻读。需要数据库提供事务隔离机制来解决：1. 读取之前加锁，阻止其他事务的更改。2. MVCC    

### 3.2 获取InnoDB行锁争用情况   
通过查询information_schema数据库相关表，通过InnoDB Monitors观察锁冲突情况    

### 3.3 InnoDB行锁模式及加锁方法
共享锁   
排它锁    
InnoDB还有两种内部使用的意向锁，这两种意向锁都是表锁   
意向共享锁：事务在给一个数据行加共享锁前，必须先获得该表的IS锁    
意向排它锁：事务在给一个数据行加排它锁前，必须先获得该表的IX锁    
如果一个事务请求的锁模式与当前的锁兼容，InnoDB就该请求的锁，赋予该事务，反之，该事务就等待锁释放   
意向锁是InnoDB自动加的，不需要用户干预。对于update、delete和insert，InnoDB会自动给涉及到的数据集加排它锁，对于SELECT语句，InnoDB不会加任何锁，事务通过以下的语句给记录加共享锁或排他锁：   
1. 共享锁 SELECT \* from table_name where ... **lock in share mode**
2. 排它锁 SELECT \* from table_name where ... **for update**  
 select ... in share mode 主要用在需要数据依存关系来确认某行记录是否存在，并确保**没有**人对这个记录**进行update或者delete操作**    如果当前事务也要**进行更新**操作，很可能造成**死锁**，对于锁定行记录后需要进行更新操作，应使用**SELECT ... for update **获得排它锁。  

### 3.4 InnoDB 行锁实现方式
InnoDB行锁是通过给**索引项**加锁来实现的，如果没有索引，InnoDB将通过隐藏的聚簇索引来对记录加锁，InnoDB行锁分为3种情形：
1. record lock  索引项加锁
2. gap lock 索引间隙加锁
3. next-key lock 前两种结合   
如果**不通过索引条件检索数据，那么InnoDB将对表中所有数据加锁，实际效果和表锁**是一样的    

**注意行锁使用索引的特性，否则导致大量的冲突，影响并发性能**一些例子：(不理解的话看书P332)   
1. 不通过索引条件查询数据，InnoDB会锁定表中所有记录    
2. 访问不同的行，使用相同的索引键，会出现锁冲突   
3. 表有多个索引的时候，不同的事务使用不同的索引锁定不同的行，不论使用的是主键索引、唯一索引或者普通索引，InnoDB都会使用行锁对数据加锁    
4. 基本使用了索引，但是Mysql认为全表扫描效率更高，InnoDB会对所有数据加锁，分析锁冲突的时候，检测SQL执行计划，确认是否真正使用到了索引。   

### 3.5 next-key 锁
当我们用范围条件而不是相等条件检索数据，并请求共享或排它锁时，InnoDB会给符合条件已有数据记录的索引项加锁，对于键值在条件范围内但不存在的记录，叫做间隙。InnoDB会对间隙加锁，这种锁机制就是next-key
Innodb 使用next-key锁的目的：防止幻读；满足恢复和复制的需要    
**使用范围条件的缺点：next-key锁定范围数据，造成严重的锁等待**   
（穿插日志格式：SBL RBL 待补充）

```sql
insert into target_tab select d1, name fron source_tab where name = '1'
```
这里没有使用MVCC一致读技术，而是给source\_tab加了锁，其原因在于保证恢复和复制的正确性。不加锁的话，这个过程其他事务对source\_tab更新，导致数据恢复结果错误（主从数据库不一致）。   

因为使用了锁，INSERT ... selcet... 和 create table ... SELECT... 可能会阻止对原表的修改，查询比较复杂，会产生严重的性能问题    

### 3.6 使用表锁的时机
**事务需要更新大部分或者全部数据，表比较大。**    
**事务涉及多个表，比较复杂，很可能引起死锁，造成大量的事务回滚**  
应用中的事务不能太多，否则就一个使用MYISAM表了    
使用表锁的注意事项：
1. 表锁不是InnoDB存储引擎层管理的，而是由Mysql server 管理的，仅当 autocommit = 0 、innodb_table-lock = 1 时, InnoDB才能感知mysql server加的锁，mysql server也才能感知InnoDB加的锁。
2. 使用lock table的正确方法
```sql
set autocommit = 0;
lock tables t2 write, t2 read, ...;
[do something with table1 and table2];
commit;
unlock tables;
```
事务结束前，**不要使用unlock释放表锁，因为unlok tables 会隐含地提交事务**。反之则不行，commit rollback不能释放表级锁。    

### 3.7 关于死锁
MYISAM总是一次获得所需的全部锁，要么满足，要么等待，不会出现死锁。但是在InnoDB中，除单个SQL组成的事务外，锁是逐步获得的，这就决定了InnoDB中发生死锁是可能的。    
发生死锁后，InnoDB一般都能自动检测到，并使一个**事务回退**，另一个事务**获得锁**，继续完成事务。但是在涉及**外部锁或涉及表锁**的情况下，InnoDB不能完全自动检测到死锁，这时需要通过设置超时等待参数 innodb\_lock\_wait\_timeout。     
几个避免减少锁冲突以及死锁的实例：   
1. 不同应用程序会并发存取多个表，应尽量约定以**相同的顺序**来访问表。    
2. 在程序批处理数据的时候，实现对数据进行**排序**，保证每个线程**按照固定顺序**来处理数据。
3. 在事务中，如果要更新记录，应该**申请足够的锁级别**，而不是先申请共享锁，再申请排它锁，因为在申请排它锁时，另一个事务获取了相同记录的共享锁，从而造成锁冲突，甚至死锁。（上文有阐述）   
4. 尽量使用**较低的隔离级别**，使用readcommit解决select for update 问题 
5. 设计良好的**索引**，加锁更加准确，减少锁冲突
6. 选择合理的**事务大小**，小事务锁冲突的几率更小
7. 尽量以**相等条件**访问数据，避免next-key锁对并发影响  




