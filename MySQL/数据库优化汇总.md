***写在前面：*** 对于数据库优化问题的回答
***我觉得可以从以下几个方面入手：***   
1. 优化SQL的一般步骤，通过**show status**，**explain, show profile, trace** 等指令  
2. 看一下**索引**问题，SQL语句中索引是否被使用上（回想索引没有被使用上的场景）
3. 一些常见的**SQL优化**（导入数据时候，INSERT数据的时候，Order by, group by, 嵌套查询，OR ，分页）
4. 优化数据库的对象，**优化数据类型，拆分表， 拟规范化，使用中间表**等等

以下是对上面每一条的展开：

## 1.优化SQL语句的一般步骤
1. 通过show status 命令了解各种SQL的执行频率
2. 定位执行效率低的SQL语句（）
3. 通过explain分析低效的SQL的执行计划
4. 通过show profile 分析SQL
5. 通过trace分析优化器如何选择执行计划
6. 确定策略并选择对应的优化措施

#### 1.1 MySQL 查询优化
查询数据的方式有全表扫描、索引全扫描、唯一索引查询、常数引用等。 通过explain语句中的type反应查询所采用的哪种方式
Type类型：   
all   
index    
range   
ref(非唯一性扫描或者索引全扫描，经常出现在join中)     eq_ref(唯一性索引扫描，单表唯一记录匹配，多表就是使用primary key 或者unique index作为关联条件)      
const/system(单表中最多匹配唯一行，根据主键primary key 或者 唯一索引 unique index 进行查询)    
null 不需要进行扫描就能得到结果   
## 2.索引的使用
通常可以通过添加合适的索引改善查询数据的方式，使其尽可能减少数据扫描行，加快查询速度。   
例如：当发现需要扫描大量的数据行但只是返回较少的行，可以考虑使用覆盖索引。   

#### 2.1 MySQL中能够使用索引的典型场景
1. 匹配全值 对索引中所有列都指定具体值，即是对所有列都有等值匹配条件  
2. 匹配值的范围查询
3. 匹配最左前缀  
4. 覆盖索引查询
5. 匹配列前缀  
6. 实现索引部分精确而其他部分进行范围匹配
7. 列名是索引，is null 就会使用到索引
8. ICP 某些条件过滤到下层存储引擎层来完成

#### 2.2 MySQL存在索引但是不能使用索引的典型场景
1. 以%开头的Like查询不能利用B-TREE索引
2. 数据类型出现隐式转换的时候不会使用索引，当列类型为字符串时，在where条件中把字符常量值用引号引起来  
3. 符合索引下，不满足最左匹配准则
4. 如果使用索引比全表扫描还慢的时候，就不要使用索引
5. 使用 or 分割开条件，or前的列有索引，而or后的列没有索引，那所涉及到的索引都不会被用到  
查看索引使用情况 Handler_read_rnd_next


## 3.常用的SQL优化

#### 3.1数据导入时进行的优化
1. 大批量数据导入：打开或者关闭MYISAM表非唯一索引的更新。将INnoDB类型的表是按照主键的顺序进行排列的，对导入数据按照主键进行排序可以提高导入数据的效率。   
2. 在导入数据的时候，关闭唯一性校验  
3. 如果应用使用自动提交方式，关闭自动提交，导入结束后再将SET AUTOCOMMIT = 1

#### 3.2优化INSERT语句
1. 同一个客户插入很多数据，尽量使用多个值表的INSERT语句。减少客户端与服务器端的连接、关闭的消耗。
2. 不同客户端插入很多行，**INSERT Delayed**。DELAYED含义是让INSERT马上执行，其实数据都存放在内存队列中，没有真正写入到磁盘，比逐条插入快的多。  
3. 将索引文件和数据文件放在不同的磁盘中进行存储。
4. bulk_insert_buffer_size(MyISAM)  
5. 文本文件装载时，Load data infile.

#### 3.3 优化order by
**3.3.1 Mysql中两种排序方式**   
1. 通过有序索引扫描返回有序数据。 Explain 时 使用using index。 
2. 第二种是对返回数据进行排序，通常所说的FileSort排序，所有不是通过索引值直接返回排序结果的都是Filesort 排序。

FileSort 是通过相应的排序算法，将取得的数据放在sort_buffer_size系统变量设置的内存排序区中进行排序，如果内存装载不下，它就会在磁盘的数据进行分块，在将各个数据库进行排序，然后合并成有序的结果集。sort_buffer_size线程独占，Mysql中存在多个sort_buffer 排序区

**3.3.2 MySQL 排序优化目标**：尽量减少额外的排序，通过索引返回有序的数据。where 条件 和 order by使用相同的索引，并且order by 的顺序和索引顺序相同，并且order by的字段都是升序或者降序。

例如：
``` sql
    explain select store_id, email, customer_id from customer where store_id = 1 order by email desc
```
使用了索引“idx\_store\_id\_email”  直接返回查询结果，无需file_sort再排序

**3.3.3对于能否直接使用索引进行排序的总结**
order by 中 混合ASC 和DESC   
where 中 条件与order by 不同   
对不同的关键字使用order by   

**3.3.4 FileSort优化**
对于FileSort MYSQL中有两种排序算法   
1. 两次扫描算法。MySQL4.1以前的算法，需要两次访问数据，第一次获取排序字段和行指针信息，第二次通过行指针获取记录。第二次操作导致大量的IO
2. 一次扫描算法。一次性选择取出满足条件的所有字段，然后在sort_buffer中排序后直接输出结果集。
通过max_length_for_sort_data 和query语句取出字段大小判断选择哪种算法。

-----
我觉得以上知道排序方式和优化目标就好啦，其他了解一下
-----


#### 3.4 优化Group by
如果查询包括group by 但是用户想要避免排序结果的消耗，可以指定order by null 禁止排序。

#### 3.5 优化嵌套查询
可以使用SELECT语句单独创建一个单列的查询结果，然后把这个单列的查询结果作为过滤条件用在另一个查询上，使用子查询可以一次性地完成很多逻辑上需要很多步骤才能完成的SQL操作， 同时也能避免事务和表锁死。有些情况下，子查询可以被更有效率的join来代替。

例如
````sql
    explain select * from customer where customer_id not in (select customer_id from payment)
````
````sql
    explain select * from customer a left join payment b on a.customer.id = b.customer.id where b.constomer.id is null 
````


#### 3.6 MySQL优化OR条件
Mysql 在处理含有OR字句的查询中，实际上是对or各个独立的索引进行查询后的结果进行了union操作。当建有复合字段的列上面做or操作，就不会用到索引

#### 3.7 MySQL优化分页查询
一般分页查询时，通过创建覆盖索引能得到很好的性能，但是一个常见又非常头疼的分页场景是“limit 1000, 20”，此时MySQL排序前1020条记录后仅仅需要返回第1001到1020条记录，前1000条记录都会被抛弃。
1. 第一种优化思路   
在索引上完成排序分页的操作，最后根据主键关联回原表查询所需的其他列内容。

````sql
    explain select a.film_id,a.description from film a inner join ( select film_id from film order by title limit 50, 5) b on a.film_id = b.film_id  
````
先根据主键索引查找对应的信息并且进行分页处理，再回原表查询所需要的其他列信息

2. 第二种优化思路
通过添加新的参数，将Limit m,n 转换成 limit n 的形式（略）


## 4. 优化数据库对象
#### 4.1 优化表的数据类型
可以使用函数procedure analyse() 对当前应用的表进行分析，该函数可以对数据表中的列的数据类型提出优化
#### 4.2 通过拆分提高表的访问效率  
第一种方法是初值拆分，把主码和一些列放到一个表，把主码和另外的列放到另一表中，缺点是需要管理冗余列，查询所有的数据需要联合操作   
第二种方法是水平拆分，根据一列或者多列的数据的值把数据行放到两个独立的表中

#### 4.3 逆规范化
增加冗余字段，减少查询时表的关联操作。注意逆规范化带来的数据完整性问题，以及带来查询速度提升时，带来的降低修改速度的问题。主要手段有以下几种： 增加冗余列，增加派生列，重组表和分割表

#### 4.4 使用中间表来提高统计查询速度
例如： 希望了解最近一周客户消费总金额 创建临时表，记录一周的情况，每次都从临时表进行查询，还可以在临时表创建索引来提高查询速度


## 5. 关于long_query 查询优化
[++参考博客++](https://www.cnblogs.com/zhouyusheng/p/8037839.html)    

超过指定时间的语句查询称为慢查询，记录在慢查询日志里
分析日志： mysqldumpslow 推荐mysql日志分析工具mysqlsla

***优化:***
1. 首先执行以下这个语句，看看是不是真的执行很慢。explain看看目前的查询情况
2. 将where 的每个条件分开进行查询，查到最小返回记录表。看看where 查询的哪个字段的区分度最高  
3. explain查看对应执行计划。
4. 如果无法解决，与业务进行沟通，看看具体的应用场景，是否可以改写sql语句。
5. 根据索引规则，创建索引
6. 观察预期，不行的话从头开始
(待补充)