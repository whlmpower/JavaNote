[++ref：Java中的锁汇总++](http://www.importnew.com/19472.html)   
[++ref：可重入锁++](https://www.zhihu.com/question/23284564)   
JAVA中锁名词：  
公平锁、非公平锁、自旋锁、可重入锁、偏向锁、轻量级锁、重量级锁、读写锁、互斥锁。   
### 公平锁和非公平锁 
公平锁：按照申请锁的先后顺序来一次获得锁。好处不会饿死  
非公平锁：效率高
ReentrantLock(true)

### 自旋锁 
Java线程都是映射到操作系统原生线程之上的，如果要阻塞或者唤醒一个线程，都需要操作系统来完成，就需要从用户态到核心态的转变，状态转变需要很长时间。  
共享数据的锁定很短时间，这段时间状态转换很不值，可以让后面请求锁的线程执行一个忙循环，这就是所谓的自旋。   
自旋时间短很值，很长的话会导致白白浪费资源，自旋有时间限制，超过了时间限制，就用传统的方式挂起。  
JDK1.6 默认开启，引入适应性自旋。**自旋是在轻量级锁中使用的，在重量级锁，线程不自旋**     
如果在同一个锁对象上，自旋等待刚刚**成功获得过锁**，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是**很有可能再次成功**，进而它将**允许自旋等待持续相对更长的时间**，比如100次循环。另外，如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能**省略掉自旋过程**，以避免浪费处理器资源。  
### 锁消除
锁消除是虚拟机JIT在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除，如果判断一段代码中，堆上面的数据都不会逃逸出去被其他线程访问，那么就把它们当成栈内数据进行处理。认为是线程私有的，加锁无需进行。    

### 锁粗化 
如果一系列操作都是对同一个对象反复的加锁和解锁，甚至加锁操作是存在循环体中，那么这一段加锁就毫无必要   
类似锁消除的concatString()方法。如果StringBuffer sb = new StringBuffer();定义在方法体之外，那么就会有线程竞争，但是每个append()操作都对同一个对象反复加锁解锁，那么虚拟机探测到有这样的情况的话，会把加锁同步的范围扩展到整个操作序列的外部，即扩展到第一个append()操作之前和最后一个append()操作之后，这样的一个锁范围扩展的操作就称之为锁粗化。   

### 重入锁
最大作用是避免死锁  
在很多情况下线程需要多次进入到锁内执行任务。   
数据库事务的实现过程中，add操作会获取锁，当一个事务中有多次add，就允许该线程多次进入临界区。  
synchronized也是重入锁，比如一个类中两个**非静态方法都被synchronized修饰**，**线程在获取synchronized访问一个方法时是可以进入到另一个synchronized方法的**（PS：应该也能进入到static方法的synchronized修饰临界区。因为是不同的两把锁，表现的不是可重入的特性）   
比如我今天遇到的一个场景：用户名和密码保存在本地txt文件中，则登录验证方法和更新密码方法都应该被加synchronized，那么当更新密码的时候需要验证密码的合法性，所以需要调用验证方法，此时是可以调用的。   
**ReentrantLock可重入锁**   
与可重入锁synchronized和lock不同的就是自旋锁。
```java
public class SpinLock {
	private AtomicReference<Thread> owner =new AtomicReference<>();
	public void lock(){
		Thread current = Thread.currentThread();
		while(!owner.compareAndSet(null, current)){
		}
	}
	public void unlock (){
		Thread current = Thread.currentThread();
		owner.compareAndSet(current, null);
	}
}

```
对于自旋锁来说，
1. 若有同一个线程两次调用lock()，会导致第二次调用lock位置进行自旋，产生死锁，说明这个锁不是可重入的(在lock函数内，应该验证线程是否已经获得锁的线程)
2. 若问题1已经解决，当unlock()第一次调用时，就已经将锁释放了，实际不应该释放锁。 (应该采用计数进行次数统计)   

```java
public class SpinLock1 {
	private AtomicReference<Thread> owner =new AtomicReference<>();
	private int count =0;
	public void lock(){
		Thread current = Thread.currentThread();
		if(current==owner.get()) {
			count++;
			return ;
		}

		while(!owner.compareAndSet(null, current)){

		}
	}
	public void unlock (){
		Thread current = Thread.currentThread();
		if(current==owner.get()){
			if(count!=0){
				count--;
			}else{
				owner.compareAndSet(current, null);
			}

		}

	}
}
```
修改之后，就可以重复进入到代码区了。   
***可重入锁是指在一个线程中可以多次获取同一把锁,比如：一个线程在执行一个带锁方法时，该方法中调用了另一个需要相同锁的方法，该线程可以直接执行调用的方法，无需重新获得锁***

### 类锁和对象锁
类锁：在方法上加static synchronized 的锁，或者synchronized(xxx.class)的锁    
对象锁：方法没有static，sychronized(this), synchronized(object)   

### 偏向锁、轻量级锁和重量级锁   
synchronized 的偏向锁、轻量级锁以及重量级锁是通过Java对象头实现的。Java对象的内存布局为：对象头、实例数据和填充。对象头又可以分为“Mark Word” 和类型指针。Mark Word是关键，默认情况下，存储对象的HashCode、分代年龄、锁标记位等。   

锁状态 | 存储内容 | 标志位
---|---|---
无锁 | 对象的hashcode、分代年龄、是否为偏向锁 | 01
轻量级锁 | 指向栈中锁记录的指针 | 00 
|重量级锁 | 指向互斥量的指针    | 01
|偏向锁   | 偏向线程ID、偏向时间戳、对象的分代年龄、是否为偏向锁(1) | 01

偏向锁是JDK 1.6 中引入的一项锁优化，目的是消除数据在无竞争情况的同步，进一步提高性能。   
偏向锁会偏向于第一个获得它的线程，如果在接下来执行中，**该锁没有被其他线程获取到**，那么持有**偏向锁的线程永远不需要同步**。大多数情况下，锁不仅不存在多线程竞争，而且总是由同一个线程多次获取到。  
当锁对象第一次被线程获取时，线程使用CAS操作把线程ID记录在对象MARK Word 中，同时偏向标志位1，以后线程进入和退出同步块的时候，都不需要进行CAS操作来加锁和解锁，只需要简单的测试一下对象头的Mark Word里面是否存在着指向当前线程的偏向锁，测试成功，说明线程已经获得了锁。   
如果线程使用CAS操作时失败表示该锁对象上存在竞争并且这个时候另外一个线程获得偏向锁的所有权，当达到安全点时，获得偏向锁的线程被挂起，膨胀为轻量级锁，同时转为轻量级锁的线程继续往下执行， 竞争的线程采用自旋来获取锁。   
### 轻量级锁
线程在执行同步块之前，JVM会先在当前线程的栈帧中创建存储锁记录(lock record)的空间，并将对象头中的Mark word 复制到锁记录中，官方成为Displayed Mark Word。线程尝试使用CAS将对象头汇总的Mark Word 替换为指向锁记录的指针。如果成功，线程获得锁，如果失败，表示其他线程竞争锁，当前线程用自旋来获取锁。如果自旋失败，锁会膨胀为重量级锁，如果自旋成功，依然处于轻量级锁。   
轻量级锁的解锁过程也是通过CAS来实现的，如果对象的MarkWork仍然指向线程的锁记录，那么就使用CAS操作把对象当前的MarkWord和线程中的Displaced Mark Word替换回来，如果替换成功，整个同步过程完成，替换失败，说明有其他线程尝试获取锁，释放锁的时候，同时唤醒被挂起线程。   
轻量级锁提升程序同步性能依据是：绝大部分的锁，在整个同步周期内都是不存在竞争的。如果没有竞争，轻量级锁使用了CAS操作避免使用互斥量的开销，如果存在竞争，除了互斥量的开销外，还额外发生了CAS操作，因此没有竞争情况下，轻量级锁比重量级锁更慢。
----
我觉得下面这个很重要
----
**整个synchronized锁流程为：** 
1. 检查Mark Word中的是否有当前线程ID，如果是，表示为当前线程处于偏向锁。   
2. 如果不是，使用CAS将Mark Word记录当前线程的ID，成功表示获得偏向锁，偏向标志位1。 
3. 如果失败，说明发生竞争，撤销偏向锁，升级为轻量级锁，同时撤销偏向锁的线程继续执行，竞争线程采用自旋来获得锁。
4. 当前线程使用CAS将对象头中Mark Work 更新为指向锁的记录的指针，如果成功，则当前线程获得锁。  
5. 如果失败，说明其他线程也在竞争锁，当前线程**采用自旋**来获取锁。
6. 自旋成功，依然为轻量级锁。
7. 自旋失败，升级为重量级锁。
8. 解锁过程也采用CAS将MARK Word替换为Displayed Mark Word的内容。
9. 成功，整个同步过程完成。
10. 失败，要在释放锁的同时，唤醒其他等待线程。

### 乐观锁和悲观锁 
悲观锁：假定最坏的情况，保证线程在执行过程中不会被其他的线程所打扰，这会导致其他需要锁的线程被挂起，等待锁的释放   
乐观锁：每次不加锁，假定每次都是没有冲突的完成某项操作，存在冲突就重试，直到成功。乐观锁避免了线程的挂起和恢复。  

### 共享锁和排它锁
共享锁：事务T对数据A加共享锁后，其他的事务只能对A加共享锁，不能加排他锁。共享锁的事务只能读数据，不能改数据  
排它锁：事务T对数据A加上排它锁后，其他事务不能对A加任何类型的锁。获得排他锁的事务既能读数据又能改数据。   
### 互斥锁
一次最多只有一个线程持有锁synchronized和JUC的Lock就是互斥锁   
### 无锁
同步只是保证贡献数据争用时的正确性手段，如果一个方法本来就不存在共享数据，一些代码天生安全
1. 无状态编码：不依赖于存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非无状态的方法等。可以参考Servlet。
2. ThreadLocal
3. volatile 
4. 协程
5. CAS(这个不应该算是乐观锁吗？)