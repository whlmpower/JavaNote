## Redis缓存设计

### 缓存收益与成本

缓存带来的收益：

1. 加速读写
2. 降低后端负载

缓存带来的成本：

1. 数据不一致性
2. 代码维护成本
3. 运维成本

缓存使用场景

1. 开销大的复杂计算：以Mysql为例子
2. 加速请求响应

### 缓存更新策略

1. LRU/LFU/FIFO算法剔除
2. 超时剔除
3. 主动更新

最佳实践：(1)低一致性的业务建议配置最大内存和淘汰策略的方式使用；(2)高一致性业务的使用超时剔除和主动更新，这样即便是主动更新出现了问题，也能保证数据过期时间后剔除脏数据。

### 缓存粒度控制

需要综合数据通用性，空间占用比，代码维护性三点进行取舍

### 穿透优化

穿透优化指查询一个根本不存在的数据，缓存层和存储层都不会命中：

1. 缓存层不命中
2. 存储层不命中，不将空结果写回缓存
3. 返回空结果

缓存穿透将导致不存在的数据每次请求都求存储层去查询，失去了缓存保护后端存储的意义。

解决缓存穿透问题：

1. 缓存空对象，空值做了缓存，意味着缓存层中存了更多的键，需要更多的内存空间，比较有效的方法是设置较短的过期时间，让其自动剔除。缓存层和存储层的数据会有一段时间窗口不一致，此时可以利用消息系统或者其他方式清除缓存中的空对象。(数据频繁变化实时性高)
2. 使用布隆过滤器进行拦截。(数据相对固定实时性低)

### 无底洞优化

分布式缓存中的批量操作

1. 串行命令。 操作时间 = n 次网络时间 + n 次命令时间
2. 串行IO。 Smart 客户端保存slot和节点的对应关系，将属于同一个节点的key进行归档，得到每个节点的key的子列表，之后对每个节点进行mget 或者 pipeline 操作，操作时间 = node次网络时间 + n 次命令时间。
3. 并行IO。 将方案二的最后一步改成多线程执行，网络次数虽然还是节点数量，操作时间为： max_slow(node 网络时间) + n 次命令时间
4. hash_tag实现。利用Redis Cluster 的hash tag，将多个key强制分配到一个节点上，操作时间： 1次网络时间 + n次命令时间。

### 雪崩优化

缓存层宕掉后，流量会像奔跑的野牛一样，打向后端存储。

1. 保证缓存层服务的高可用性
2. 依赖隔离组件为后端限流并降级(Netflix Hystrix)
3. 提前演练

### 热点key重建优化

当前key是一个热点key，并发量非常大。

重建缓存不可能在短时间内完成。

在缓存失效的瞬间，有大量的线程来重建缓存，造成后端负载加大，甚至可能让应用崩溃。

制定如下目标：

1. 减少重建缓存次数
2. 数据尽可能一致
3. 较少的潜在风险

解决方案：

1. 互斥锁。此方法只允许一个线程来重建缓存，其他线程等待常见缓存的线程执行完，重新从缓存中获取数据即可，使用Redis的setnx命令来实现上述功能：

```Java
String get(String key){
    String value = redis.get(key);
    if(value == null){
        String mutexKey = "mutext:key:" + key;
        if(redis.set(mutexKey, "1", "ex 180", "nx")){
            value = db.get(key);
            redis.setex(key, timeout, value);
            redis.delete(mutexKey);
        }else{
            Thread.sleep(50);
            get(key);
        }
    }
    return key;
}
```

缺点：构建缓存过程出现问题或者时间过长，存在死锁和线程池阻塞的风险。

优点：降低后端负载，并在一致性做的比较好

2. 数据永不过期

为每个value设置一个逻辑的过期时间，当发现超过这个逻辑过期时间后，会使用单独的线程去构建缓存。

此方法杜绝了热点key产生的问题，但唯一不足的就是重建缓存时期，会出现数据的不一致情况。



